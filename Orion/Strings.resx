<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AssemblyLoadFailedException" xml:space="preserve">
    <value>Failed to load assembly \"{0}\".</value>
    <comment>Used in an exception when a plugin assembly cannot be loaded during plugin loading</comment>
  </data>
  <data name="BCryptHashLengthOutOfRange" xml:space="preserve">
    <value>String must be &gt; {0} characters.</value>
    <comment>Used in an exception if a string length is less than the given minimum length</comment>
  </data>
  <data name="BCryptHashWorkFactorOutOfRange" xml:space="preserve">
    <value>Invalid BCrypt work factor provided! Creating new hash using default work factor.</value>
    <comment>Output when a bad BCrypt work factor is passed to the CreateBCryptHash(...) method</comment>
  </data>
  <data name="BCryptHashWorkFactorOutOfRangeUpgrade" xml:space="preserve">
    <value>Invalid BCrypt work factor provided! Upgrading input to BCrypt using default work factor.</value>
    <comment>Output when a bad BCrypt work factor is passed to the UpgradeInput(...) method</comment>
  </data>
  <data name="BCryptInvalidHashFormat" xml:space="preserve">
    <value>Warning: Not upgrading work factor because bcrypt hash in an invalid format.</value>
    <comment>Output when a badly formatted hash is passed to the UpgradeHashWorkFactor(...) method</comment>
  </data>
  <data name="BCryptInvalidWorkFactor" xml:space="preserve">
    <value>Invalid BCrypt work factor provided! Refusing to change work-factor on exsting hash.</value>
    <comment>Output when a bad work factor is passed to the UpgradeHashWorkFactor(...) method</comment>
  </data>
  <data name="ConfigPathCmdLineOutput" xml:space="preserve">
    <value>Config path has been set to {0}.</value>
    <comment>Output when the ConfigPath is set via command line</comment>
  </data>
  <data name="GroupNotFound" xml:space="preserve">
    <value>Group '{0}' does not exist.</value>
    <comment>Used when attempting to set a non-existant group</comment>
  </data>
  <data name="HashAlgoUnsupported" xml:space="preserve">
    <value>Hashing algorithm {0} is not supported.</value>
    <comment>Used in an exception when the config file attempts to use an unsupported hashing algorithm. This is for legacy hashed values that must be updated to BCrypt</comment>
  </data>
  <data name="InvalidDbTypeException" xml:space="preserve">
    <value>Invalid storage type.</value>
    <comment>Used in an exception if Orion's SQL configuration is invalid on startup</comment>
  </data>
  <data name="MySqlException" xml:space="preserve">
    <value>MySql not setup correctly.</value>
    <comment>Used in an exception if Orion's MySQL configuration is invalid on startup</comment>
  </data>
  <data name="PluginDisposedOutput" xml:space="preserve">
    <value>Orion plugin \"{0}\" has thrown an exception while being disposed: 
{1}.</value>
    <comment>Output when a plugin throws an exception while disposing</comment>
  </data>
  <data name="PluginIgnoredOutput" xml:space="preserve">
    <value>Orion plugin \"{0}\" is designed for a different Orion version ({1}) and was ignored.</value>
    <comment>Output when a plugin is ignored during plugin loading</comment>
  </data>
  <data name="PluginInitializeException" xml:space="preserve">
    <value>Orion plugin \"{0}\" has thrown an exception during initialization.</value>
    <comment>Used in an exception when a plugin throws an exception while initializing</comment>
  </data>
  <data name="PluginInstanceFailedException" xml:space="preserve">
    <value>Could not create an instance of orion plugin class \"{0}\".</value>
    <comment>Used in an exception when an instance of a plugin cannot be created during plugin loading</comment>
  </data>
  <data name="PluginsLoadedOutput" xml:space="preserve">
    <value>Orion has successfully loaded the following plugins: 
{0}</value>
    <comment>Output when Orion has finished loading plugins</comment>
  </data>
  <data name="SavePathCmdLineOutput" xml:space="preserve">
    <value>Save path has been set to {0}.</value>
    <comment>Output when the SavePath is set via command line</comment>
  </data>
  <data name="StartupException" xml:space="preserve">
    <value>Fatal startup exception.</value>
    <comment>Used in an exception if Orion fails to start for some reason</comment>
  </data>
  <data name="TextLogDisposedOutput" xml:space="preserve">
    <value>Unable to write to log as log has been disposed.</value>
    <comment>Output when an attempt to log is made, but the log object has been disposed</comment>
  </data>
  <data name="UserCollision" xml:space="preserve">
    <value>User '{0}' already exists.</value>
    <comment>Used in a UserCollision exception</comment>
  </data>
  <data name="UserHandlerSetParameterInvalidArgs" xml:space="preserve">
    <value>Invalid arguments in UserHandler.SetParameters: password, group and uuid may not all be null.</value>
    <comment>Used in an exception when password, group, and UUID are passed to SetParameters(...) as nulls</comment>
  </data>
  <data name="UserHandlerSetParameterUserIDError" xml:space="preserve">
    <value>UserHandler.SetParameter returned an error for User ID {0}.</value>
    <comment>Used in an exception when SetParameters(...) throws an exception for the given UUID</comment>
  </data>
  <data name="UserIDLessThanZero" xml:space="preserve">
    <value>User ID may not be less than 0.</value>
    <comment>Used in an exception when a positive UserID is expected but a negative UserIDis received</comment>
  </data>
  <data name="UserNotFound" xml:space="preserve">
    <value>User '{0}' does not exist.</value>
    <comment>Used in a UserNotFound exception</comment>
  </data>
</root>